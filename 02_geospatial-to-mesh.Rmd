---
output: html_document
editor_options: 
  chunk_output_type: console
---


# Transforming spatial data to 3D forms

## Questions

* What tools exist to convert data to meshes in R? 

## Image textures

This section requires a Mapbox API key to run from scratch - so the data has been made available in the download for this session. 


Munster is here. 


```{r ceramic, eval=FALSE, echo=FALSE}
loc <- cbind(7 + 37.5/60, 51 + 57.6/60)
buffer <- 9000
library(ceramic)

munster_elev <- cc_elevation(loc, buffer, zoom = 12)
munster_imag <- cc_location(loc, buffer, zoom = 14)

```

The process is a little complicated, but the key is that the elevation raster provides a space in which to map other data too. In this case the raster is in Mercator, and the image is as well. Under the hood we have to map the spatial part of the image into 0, 1, 0, 1 space of a PNG image, but in the final event we get a scene where real-world data may be added directly. 

```{r ceramic-cache}
munster_qmesh <- quadmesh::quadmesh(munster_elev, texture = munster_imag)

rgl::shade3d(munster_qmesh, lit = FALSE); rgl::aspect3d(1, 1, .05)

## more exact location of THIS building
merc <- sf::sf_project(cbind(7.59551, 51.96922), from = "+init=epsg:4326", to = raster::projection(munster_elev))
rgl::lines3d(cbind(merc[c(1, 1), ], matrix(c(0, 1000))))
```


## Transforming Spatial Data using modular 3D tools {.exercise}

1. Tell us if you use 3D visualization or meshes in analysis. 


This is hard! There's a few scattered tools. 

## On CRAN 

* `rgl::triangulate` and `decido::earcut` will triangulate polygons with holes but only suitable for plane-filling, because ugly triangles, no control over size and shape. 

* `RTriangle::triangulate` (and `sfdct::ct_triangulate`) do high-quality "near-Delaunay" triangulations

* `quadmesh::quadmesh` to create rgl-ready mesh3d from a raster

* `mapview::cubeView` does very compelling interactive raster-cube visualization

* `SymbolixAU/mapdeck`

* `tylermorganwall/rayshader`


Side note: there are many triangulation algorithms and many packages in R, but we need *constrained triangulation* to preserve all input edges - only a handful can do that, and RTriangle is the king (with a problematic license). 


## Quadmesh. 


```{r, quadmesh, eval=FALSE}
library(quadmesh)
quadmesh(anyRasterDEM, texture = anyRasterRGB)
rgl::shade3d()

## play with aspect3d, light3d, ...

```

Triangulations, `sfdct` is no good because it's very inefficient. `sf` is simply not suitable for mesh (a.k.a. *indexed*) forms of data. 


## Stuff not on CRAN!

* `hypertidy/silicate`, `hypertidy/anglr` - these are evolving together 

* https://github.com/MilesMcBain/gis_vs_web3D 

* `coolbutuseless/threed`


## Triangles or quads in hypertidy (WIP)

This is my work-in-progress approach to meshing any data structure. 


```{r, eval=FALSE}
## devtools::install_github("hypertidy/anglr")
## devtools::install_github("hypertidy/silicate")
library(anglr)  
triangles <- copy_down(TRI(anySFpolygon), anyRasterDEM)

mesh <- plot3d(triangles)

```









