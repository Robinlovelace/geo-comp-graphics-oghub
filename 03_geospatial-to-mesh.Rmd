---
output: html_document
editor_options: 
  chunk_output_type: console
---


# Transforming spatial data to 3D forms

The key package is rgl, the OpenGL package for R. This tends to be very low level, but has improved helpers and is becoming easier to use. The key functions are `plot3d`, `lines3d` and `points3d` and these are used just like the 2D base funtions in R (with the '3d' on the end). 


There is a special function called `shade3d` and this one accepts the `mesh3d` object that we introduced via the quadmesh package earlier. 




## Questions

* What tools exist to convert data to meshes in R? 
* What forms of mesh data are available? 


The .obj format: https://github.com/odedstein/meshes/tree/master/objects/koala


## Image textures

This section requires a Mapbox API key to run from scratch - and can't be shared, so it will simply be illustrated. 


Munster is here. 


```{r ceramic, eval=FALSE, echo=FALSE}
loc <- cbind(7 + 37.5/60, 51 + 57.6/60)
buffer <- 9000
library(ceramic)

munster_elev <- cc_elevation(loc, buffer, zoom = 12)
munster_imag <- cc_location(loc, buffer, zoom = 14)

```

The process is a little complicated, but the key is that the elevation raster provides a space in which to map other data too. In this case the raster is in Mercator, and the image is as well. Under the hood we have to map the spatial part of the image into 0, 1, 0, 1 space of a PNG image, but in the final event we get a scene where real-world data may be added directly. 

```{r ceramic-cache, eval=FALSE, include=TRUE}
munster_qmesh <- quadmesh::quadmesh(munster_elev, texture = munster_imag)

rgl::shade3d(munster_qmesh, lit = FALSE); rgl::aspect3d(1, 1, .05)

## more exact location of THIS building
merc <- sf::sf_project(cbind(7.59551, 51.96922), from = "+init=epsg:4326", to = raster::projection(munster_elev))
rgl::lines3d(cbind(merc[c(1, 1), ], matrix(c(0, 1000))))
```


## Transforming Spatial Data using modular 3D tools {.exercise}

1. Tell us if you use 3D visualization or meshes in analysis. 


This is hard! There's a few scattered tools. 

## On CRAN 

* `rgl::triangulate` and `decido::earcut` will triangulate polygons with holes but only suitable for plane-filling, because ugly triangles, no control over size and shape. 

* `RTriangle::triangulate` (and `sfdct::ct_triangulate`) do high-quality "near-Delaunay" triangulations

* `quadmesh::quadmesh` to create rgl-ready mesh3d from a raster

* `mapview::cubeView` does very compelling interactive raster-cube visualization

* `SymbolixAU/mapdeck`

* `tylermorganwall/rayshader`


Side note: there are many triangulation algorithms and many packages in R, but we need *constrained triangulation* to preserve all input edges - only a handful can do that, and RTriangle is the king (with a problematic license). 


## Quadmesh. 


```{r, quadmesh, eval=FALSE}
library(quadmesh)
quadmesh(anyRasterDEM, texture = anyRasterRGB)
rgl::shade3d()

## play with aspect3d, light3d, ...

```

Triangulations, `sfdct` is no good because it's very inefficient. `sf` is simply not suitable for mesh (a.k.a. *indexed*) forms of data. 


## Stuff not on CRAN!

* `hypertidy/silicate`, `hypertidy/anglr` - these are evolving together 

* https://github.com/MilesMcBain/gis_vs_web3D 

* `coolbutuseless/threed`


## Triangles or quads in hypertidy (WIP)

This is my work-in-progress approach to meshing any data structure. 


```{r, eval=FALSE}
## devtools::install_github("hypertidy/anglr")
## devtools::install_github("hypertidy/silicate")
library(anglr)  
triangles <- copy_down(TRI(anySFpolygon), anyRasterDEM)

mesh <- plot3d(triangles)

```









